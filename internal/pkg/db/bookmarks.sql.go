// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bookmarks.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	pgv "github.com/pgvector/pgvector-go"
)

const createBookmark = `-- name: CreateBookmark :one
INSERT INTO bookmarks (
    uuid,
    user_id,
    url,
    title,
    summary,
    summary_embeddings,
    content,
    content_embeddings,
    html,
    metadata,
    screenshot
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, uuid, user_id, url, title, summary, summary_embeddings, content, content_embeddings, html, metadata, screenshot, created_at, updated_at
`

type CreateBookmarkParams struct {
	Uuid              uuid.UUID
	UserID            pgtype.UUID
	Url               string
	Title             pgtype.Text
	Summary           pgtype.Text
	SummaryEmbeddings *pgv.Vector
	Content           pgtype.Text
	ContentEmbeddings *pgv.Vector
	Html              pgtype.Text
	Metadata          []byte
	Screenshot        pgtype.Text
}

func (q *Queries) CreateBookmark(ctx context.Context, db DBTX, arg CreateBookmarkParams) (Bookmark, error) {
	row := db.QueryRow(ctx, createBookmark,
		arg.Uuid,
		arg.UserID,
		arg.Url,
		arg.Title,
		arg.Summary,
		arg.SummaryEmbeddings,
		arg.Content,
		arg.ContentEmbeddings,
		arg.Html,
		arg.Metadata,
		arg.Screenshot,
	)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.Summary,
		&i.SummaryEmbeddings,
		&i.Content,
		&i.ContentEmbeddings,
		&i.Html,
		&i.Metadata,
		&i.Screenshot,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBookmark = `-- name: DeleteBookmark :exec
DELETE FROM bookmarks WHERE uuid = $1 AND user_id = $2
`

type DeleteBookmarkParams struct {
	Uuid   uuid.UUID
	UserID pgtype.UUID
}

func (q *Queries) DeleteBookmark(ctx context.Context, db DBTX, arg DeleteBookmarkParams) error {
	_, err := db.Exec(ctx, deleteBookmark, arg.Uuid, arg.UserID)
	return err
}

const deleteBookmarksByUser = `-- name: DeleteBookmarksByUser :exec
DELETE FROM bookmarks WHERE user_id = $1
`

func (q *Queries) DeleteBookmarksByUser(ctx context.Context, db DBTX, userID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteBookmarksByUser, userID)
	return err
}

const getBookmarkByURL = `-- name: GetBookmarkByURL :one
SELECT id, uuid, user_id, url, title, summary, summary_embeddings, content, content_embeddings, html, metadata, screenshot, created_at, updated_at FROM bookmarks WHERE url = $1 AND user_id = $2
`

type GetBookmarkByURLParams struct {
	Url    string
	UserID pgtype.UUID
}

func (q *Queries) GetBookmarkByURL(ctx context.Context, db DBTX, arg GetBookmarkByURLParams) (Bookmark, error) {
	row := db.QueryRow(ctx, getBookmarkByURL, arg.Url, arg.UserID)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.Summary,
		&i.SummaryEmbeddings,
		&i.Content,
		&i.ContentEmbeddings,
		&i.Html,
		&i.Metadata,
		&i.Screenshot,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBookmarkByUUID = `-- name: GetBookmarkByUUID :one
SELECT id, uuid, user_id, url, title, summary, summary_embeddings, content, content_embeddings, html, metadata, screenshot, created_at, updated_at FROM bookmarks WHERE uuid = $1
`

func (q *Queries) GetBookmarkByUUID(ctx context.Context, db DBTX, argUuid uuid.UUID) (Bookmark, error) {
	row := db.QueryRow(ctx, getBookmarkByUUID, argUuid)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.Summary,
		&i.SummaryEmbeddings,
		&i.Content,
		&i.ContentEmbeddings,
		&i.Html,
		&i.Metadata,
		&i.Screenshot,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listBookmarks = `-- name: ListBookmarks :many
WITH total AS (
    SELECT COUNT(*) AS total_count 
    FROM bookmarks 
    WHERE user_id = $1
)
SELECT b.id, b.uuid, b.user_id, b.url, b.title, b.summary, b.summary_embeddings, b.content, b.content_embeddings, b.html, b.metadata, b.screenshot, b.created_at, b.updated_at, t.total_count 
FROM bookmarks b, total t
WHERE b.user_id = $1 
ORDER BY b.updated_at DESC 
LIMIT $2 OFFSET $3
`

type ListBookmarksParams struct {
	UserID pgtype.UUID
	Limit  int32
	Offset int32
}

type ListBookmarksRow struct {
	ID                int32
	Uuid              uuid.UUID
	UserID            pgtype.UUID
	Url               string
	Title             pgtype.Text
	Summary           pgtype.Text
	SummaryEmbeddings *pgv.Vector
	Content           pgtype.Text
	ContentEmbeddings *pgv.Vector
	Html              pgtype.Text
	Metadata          []byte
	Screenshot        pgtype.Text
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	TotalCount        int64
}

func (q *Queries) ListBookmarks(ctx context.Context, db DBTX, arg ListBookmarksParams) ([]ListBookmarksRow, error) {
	rows, err := db.Query(ctx, listBookmarks, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListBookmarksRow
	for rows.Next() {
		var i ListBookmarksRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.UserID,
			&i.Url,
			&i.Title,
			&i.Summary,
			&i.SummaryEmbeddings,
			&i.Content,
			&i.ContentEmbeddings,
			&i.Html,
			&i.Metadata,
			&i.Screenshot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ownerTransferBookmark = `-- name: OwnerTransferBookmark :exec
UPDATE bookmarks 
SET 
    user_id = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
`

type OwnerTransferBookmarkParams struct {
	UserID   pgtype.UUID
	UserID_2 pgtype.UUID
}

func (q *Queries) OwnerTransferBookmark(ctx context.Context, db DBTX, arg OwnerTransferBookmarkParams) error {
	_, err := db.Exec(ctx, ownerTransferBookmark, arg.UserID, arg.UserID_2)
	return err
}

const updateBookmark = `-- name: UpdateBookmark :one
UPDATE bookmarks 
SET 
    title = COALESCE($3, title),
    summary = COALESCE($4, summary),
    summary_embeddings = COALESCE($5, summary_embeddings),
    content = COALESCE($6, content),
    content_embeddings = COALESCE($7, content_embeddings),
    html = COALESCE($8, html),
    metadata = COALESCE($9, metadata),
    screenshot = COALESCE($10, screenshot),
    updated_at = CURRENT_TIMESTAMP
WHERE uuid = $1 AND user_id = $2
RETURNING id, uuid, user_id, url, title, summary, summary_embeddings, content, content_embeddings, html, metadata, screenshot, created_at, updated_at
`

type UpdateBookmarkParams struct {
	Uuid              uuid.UUID
	UserID            pgtype.UUID
	Title             pgtype.Text
	Summary           pgtype.Text
	SummaryEmbeddings *pgv.Vector
	Content           pgtype.Text
	ContentEmbeddings *pgv.Vector
	Html              pgtype.Text
	Metadata          []byte
	Screenshot        pgtype.Text
}

func (q *Queries) UpdateBookmark(ctx context.Context, db DBTX, arg UpdateBookmarkParams) (Bookmark, error) {
	row := db.QueryRow(ctx, updateBookmark,
		arg.Uuid,
		arg.UserID,
		arg.Title,
		arg.Summary,
		arg.SummaryEmbeddings,
		arg.Content,
		arg.ContentEmbeddings,
		arg.Html,
		arg.Metadata,
		arg.Screenshot,
	)
	var i Bookmark
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.Summary,
		&i.SummaryEmbeddings,
		&i.Content,
		&i.ContentEmbeddings,
		&i.Html,
		&i.Metadata,
		&i.Screenshot,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
