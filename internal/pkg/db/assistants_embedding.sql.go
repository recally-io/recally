// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: assistants_embedding.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const createAssistantEmbedding = `-- name: CreateAssistantEmbedding :exec
INSERT INTO assistant_embedddings (uuid, user_id, attachment_id, text, embeddings, metadata)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateAssistantEmbeddingParams struct {
	Uuid         uuid.UUID
	UserID       pgtype.UUID
	AttachmentID pgtype.UUID
	Text         string
	Embeddings   pgvector.Vector
	Metadata     []byte
}

// CRUD for assistant_message_embedddings
func (q *Queries) CreateAssistantEmbedding(ctx context.Context, db DBTX, arg CreateAssistantEmbeddingParams) error {
	_, err := db.Exec(ctx, createAssistantEmbedding,
		arg.Uuid,
		arg.UserID,
		arg.AttachmentID,
		arg.Text,
		arg.Embeddings,
		arg.Metadata,
	)
	return err
}

const deleteAssistantEmbeddings = `-- name: DeleteAssistantEmbeddings :exec
DELETE FROM assistant_embedddings WHERE id = $1
`

func (q *Queries) DeleteAssistantEmbeddings(ctx context.Context, db DBTX, id int32) error {
	_, err := db.Exec(ctx, deleteAssistantEmbeddings, id)
	return err
}

const deleteAssistantEmbeddingsByAssistantId = `-- name: DeleteAssistantEmbeddingsByAssistantId :exec
DELETE FROM assistant_embedddings
USING assistant_attachments aa
WHERE aa.uuid = em.attachment_id AND aa.assistant_id = $1
`

// This is a bit tricky, because we need to delete all embeddings for all threads of the assistant
func (q *Queries) DeleteAssistantEmbeddingsByAssistantId(ctx context.Context, db DBTX, assistantID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAssistantEmbeddingsByAssistantId, assistantID)
	return err
}

const deleteAssistantEmbeddingsByAttachmentId = `-- name: DeleteAssistantEmbeddingsByAttachmentId :exec
DELETE FROM assistant_embedddings WHERE attachment_id = $1
`

func (q *Queries) DeleteAssistantEmbeddingsByAttachmentId(ctx context.Context, db DBTX, attachmentID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAssistantEmbeddingsByAttachmentId, attachmentID)
	return err
}

const deleteAssistantEmbeddingsByThreadId = `-- name: DeleteAssistantEmbeddingsByThreadId :exec
DELETE FROM assistant_embedddings em
USING assistant_attachments aa
WHERE aa.uuid = em.attachment_id AND aa.thread_id = $1
`

func (q *Queries) DeleteAssistantEmbeddingsByThreadId(ctx context.Context, db DBTX, threadID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAssistantEmbeddingsByThreadId, threadID)
	return err
}

const isAssistantEmbeddingExists = `-- name: IsAssistantEmbeddingExists :one
SELECT EXISTS (
    SELECT 1
    FROM assistant_embedddings
    WHERE uuid = $1
) AS exists
`

func (q *Queries) IsAssistantEmbeddingExists(ctx context.Context, db DBTX, argUuid uuid.UUID) (bool, error) {
	row := db.QueryRow(ctx, isAssistantEmbeddingExists, argUuid)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const similaritySearchByThreadId = `-- name: SimilaritySearchByThreadId :many
SELECT em.id, em.text, em.metadata, 1 - (em.embeddings <=> $2) AS score
FROM assistant_embedddings em
JOIN assistant_attachments att ON em.attachment_id = att.uuid
JOIN assistant_threads th ON (th.uuid = att.thread_id OR th.assistant_id = att.assistant_id)
WHERE th.uuid = $1
    AND em.embeddings <=> $2
ORDER BY score DESC
LIMIT $3
`

type SimilaritySearchByThreadIdParams struct {
	Uuid       uuid.UUID
	Embeddings pgvector.Vector
	Limit      int32
}

type SimilaritySearchByThreadIdRow struct {
	ID       int32
	Text     string
	Metadata []byte
	Score    int32
}

func (q *Queries) SimilaritySearchByThreadId(ctx context.Context, db DBTX, arg SimilaritySearchByThreadIdParams) ([]SimilaritySearchByThreadIdRow, error) {
	rows, err := db.Query(ctx, similaritySearchByThreadId, arg.Uuid, arg.Embeddings, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SimilaritySearchByThreadIdRow
	for rows.Next() {
		var i SimilaritySearchByThreadIdRow
		if err := rows.Scan(
			&i.ID,
			&i.Text,
			&i.Metadata,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
