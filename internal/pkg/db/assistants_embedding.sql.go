// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: assistants_embedding.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	pgv "github.com/pgvector/pgvector-go"
)

const createAssistantEmbedding = `-- name: CreateAssistantEmbedding :exec
INSERT INTO assistant_embedddings (uuid, user_id, attachment_id, text, embeddings, metadata)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateAssistantEmbeddingParams struct {
	Uuid         uuid.UUID
	UserID       pgtype.UUID
	AttachmentID pgtype.UUID
	Text         string
	Embeddings   *pgv.Vector
	Metadata     []byte
}

// CRUD for assistant_message_embedddings
func (q *Queries) CreateAssistantEmbedding(ctx context.Context, db DBTX, arg CreateAssistantEmbeddingParams) error {
	_, err := db.Exec(ctx, createAssistantEmbedding,
		arg.Uuid,
		arg.UserID,
		arg.AttachmentID,
		arg.Text,
		arg.Embeddings,
		arg.Metadata,
	)
	return err
}

const deleteAssistantEmbeddings = `-- name: DeleteAssistantEmbeddings :exec
DELETE FROM assistant_embedddings WHERE id = $1
`

func (q *Queries) DeleteAssistantEmbeddings(ctx context.Context, db DBTX, id int32) error {
	_, err := db.Exec(ctx, deleteAssistantEmbeddings, id)
	return err
}

const deleteAssistantEmbeddingsByAssistantId = `-- name: DeleteAssistantEmbeddingsByAssistantId :exec
DELETE FROM assistant_embedddings
USING assistant_attachments aa
WHERE aa.uuid = em.attachment_id AND aa.assistant_id = $1
`

// This is a bit tricky, because we need to delete all embeddings for all threads of the assistant
func (q *Queries) DeleteAssistantEmbeddingsByAssistantId(ctx context.Context, db DBTX, assistantID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAssistantEmbeddingsByAssistantId, assistantID)
	return err
}

const deleteAssistantEmbeddingsByAttachmentId = `-- name: DeleteAssistantEmbeddingsByAttachmentId :exec
DELETE FROM assistant_embedddings WHERE attachment_id = $1
`

func (q *Queries) DeleteAssistantEmbeddingsByAttachmentId(ctx context.Context, db DBTX, attachmentID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAssistantEmbeddingsByAttachmentId, attachmentID)
	return err
}

const deleteAssistantEmbeddingsByThreadId = `-- name: DeleteAssistantEmbeddingsByThreadId :exec
DELETE FROM assistant_embedddings em
USING assistant_attachments aa
WHERE aa.uuid = em.attachment_id AND aa.thread_id = $1
`

func (q *Queries) DeleteAssistantEmbeddingsByThreadId(ctx context.Context, db DBTX, threadID pgtype.UUID) error {
	_, err := db.Exec(ctx, deleteAssistantEmbeddingsByThreadId, threadID)
	return err
}

const isAssistantEmbeddingExists = `-- name: IsAssistantEmbeddingExists :one
SELECT EXISTS (
    SELECT 1
    FROM assistant_embedddings
    WHERE uuid = $1
) AS exists
`

func (q *Queries) IsAssistantEmbeddingExists(ctx context.Context, db DBTX, argUuid uuid.UUID) (bool, error) {
	row := db.QueryRow(ctx, isAssistantEmbeddingExists, argUuid)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const similaritySearchByThreadId = `-- name: SimilaritySearchByThreadId :many
SELECT em.id, em.user_id, em.attachment_id, em.text, em.embeddings, em.metadata, em.created_at, em.updated_at, em.uuid
FROM assistant_embedddings em
JOIN assistant_attachments att ON em.attachment_id = att.uuid
JOIN assistant_threads th ON (th.uuid = att.thread_id OR th.assistant_id = att.assistant_id)
WHERE th.uuid = $1 AND (em.embeddings <=> $2 < 0.5)
ORDER BY 1 - (em.embeddings <=> $2) DESC
LIMIT $3
`

type SimilaritySearchByThreadIdParams struct {
	Uuid       uuid.UUID
	Embeddings *pgv.Vector
	Limit      int32
}

func (q *Queries) SimilaritySearchByThreadId(ctx context.Context, db DBTX, arg SimilaritySearchByThreadIdParams) ([]AssistantEmbeddding, error) {
	rows, err := db.Query(ctx, similaritySearchByThreadId, arg.Uuid, arg.Embeddings, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AssistantEmbeddding
	for rows.Next() {
		var i AssistantEmbeddding
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AttachmentID,
			&i.Text,
			&i.Embeddings,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Uuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
